#!/usr/bin/env bash
# Localsetup v2  - Front-end install script
# Purpose: Deploy Localsetup v2 into a client repo at _localsetup/ and write
#   platform-specific context loaders and skills per selected tools.
#
# Usage:
#   Interactive:   curl -sSL https://raw.githubusercontent.com/cptnfren/localsetup/main/install | bash
#   Non-interactive: curl ... | bash -s -- --directory . --tools cursor --yes
#   Help:          install --help  or  install -h
#
# Options:
#   --directory PATH   Client repo root (default: . or prompt). Must exist.
#   --tools LIST       Comma-separated tools (required with --yes). See below.
#   --yes              Non-interactive; no prompts. Requires --tools.
#   --help, -h         Print this help and exit.
#
# Tools (valid values for --tools):
#   cursor       Cursor IDE (.cursor/rules, .cursor/skills)
#   claude-code  Claude Code (.claude/CLAUDE.md, .claude/skills)
#   codex        OpenAI Codex CLI (AGENTS.md, .agents/skills)
#   openclaw     OpenClaw (skills/, _localsetup/docs/OPENCLAW_CONTEXT.md)
#
# Examples:
#   install --directory . --tools cursor --yes
#   install --tools cursor,claude-code --yes
#   install
#
# On Windows: run install.ps1; or from Git Bash this script delegates to install.ps1.

set -euo pipefail

# Delegate to PowerShell on Windows when run from Git Bash / MSYS / Cygwin
if [[ -n "${WINDIR:-}" ]] || [[ "${OSTYPE:-}" == "msys" ]] || [[ "${OSTYPE:-}" == "cygwin" ]]; then
  INSTALL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  if command -v pwsh >/dev/null 2>&1; then
    exec pwsh -NoProfile -ExecutionPolicy Bypass -File "$INSTALL_DIR/install.ps1" "$@"
  else
    exec powershell -NoProfile -ExecutionPolicy Bypass -File "$INSTALL_DIR/install.ps1" "$@"
  fi
fi

REPO_URL="${LOCALSETUP_2_REPO:-https://github.com/cptnfren/localsetup.git}"
FRAMEWORK_DIRNAME="_localsetup"
TARGET_DIR=""
TOOLS_CSV=""
NONINTERACTIVE=false
MIN_GIT_VERSION="2.20.0"

# Help text inline so it works when script is piped (curl | bash); $0 is not the script then.
usage() {
  cat << 'USAGE_END'
Localsetup v2  - Front-end install script
Purpose: Deploy Localsetup v2 into a client repo at _localsetup/ and write
  platform-specific context loaders and skills per selected tools.

Usage:
  Interactive:   curl -sSL https://raw.githubusercontent.com/cptnfren/localsetup/main/install | bash
  Non-interactive: curl ... | bash -s -- --directory . --tools cursor --yes
  Help:          install --help  or  install -h

Options:
  --directory PATH   Client repo root (default: . or prompt). Must exist.
  --tools LIST       Comma-separated tools (required with --yes). See below.
  --yes              Non-interactive; no prompts. Requires --tools.
  --help, -h         Print this help and exit.

Tools (valid values for --tools):
  cursor       Cursor IDE (.cursor/rules, .cursor/skills)
  claude-code  Claude Code (.claude/CLAUDE.md, .claude/skills)
  codex        OpenAI Codex CLI (AGENTS.md, .agents/skills)
  openclaw     OpenClaw (skills/, _localsetup/docs/OPENCLAW_CONTEXT.md)

Examples:
  install --directory . --tools cursor --yes
  install --tools cursor,claude-code --yes
  install

On Windows: run install.ps1; or from Git Bash this script delegates to install.ps1.
USAGE_END
}

show_help_and_exit() {
  usage
  exit 0
}

show_usage_and_exit() {
  echo "Error: $1" >&2
  usage >&2
  exit 1
}

version_ge() {
  # Returns 0 when $1 >= $2 for semantic-ish x.y.z versions.
  local a b i
  IFS='.' read -r -a a <<< "${1:-0.0.0}"
  IFS='.' read -r -a b <<< "${2:-0.0.0}"
  for i in 0 1 2; do
    local av="${a[$i]:-0}"
    local bv="${b[$i]:-0}"
    ((10#$av > 10#$bv)) && return 0
    ((10#$av < 10#$bv)) && return 1
  done
  return 0
}

preflight_checks() {
  local required_fail=0
  local git_status="MISSING"
  local python_status="MISSING (optional)"
  local pip_status="MISSING (optional)"
  local git_version=""

  if command -v git >/dev/null 2>&1; then
    git_version="$(git --version 2>/dev/null | sed -E 's/^git version ([0-9]+(\.[0-9]+){0,2}).*/\1/')"
    if [[ -z "$git_version" ]]; then
      git_status="FOUND (version unknown)"
    elif version_ge "$git_version" "$MIN_GIT_VERSION"; then
      git_status="OK ($git_version)"
    else
      git_status="TOO OLD ($git_version, need >= $MIN_GIT_VERSION)"
      required_fail=1
    fi
  else
    required_fail=1
  fi

  if command -v python3 >/dev/null 2>&1; then
    python_status="FOUND ($(python3 --version 2>/dev/null | awk '{print $2}'))"
  elif command -v python >/dev/null 2>&1; then
    python_status="FOUND ($(python --version 2>&1 | awk '{print $2}'))"
  fi

  if command -v pip3 >/dev/null 2>&1; then
    pip_status="FOUND ($(pip3 --version 2>/dev/null | awk '{print $2}'))"
  elif command -v pip >/dev/null 2>&1; then
    pip_status="FOUND ($(pip --version 2>/dev/null | awk '{print $2}'))"
  fi

  echo "Dependency preflight:"
  echo "  Required:"
  echo "    - git: $git_status"
  echo "  Optional (advanced tooling only):"
  echo "    - python: $python_status"
  echo "    - pip: $pip_status"

  if [[ "$required_fail" -ne 0 ]]; then
    echo
    echo "Cannot continue: required dependencies are missing or incompatible."
    echo "Install/upgrade the required tools, then run install again."
    exit 1
  fi
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --directory)
      if [[ $# -lt 2 ]]; then
        show_usage_and_exit "Missing value for --directory"
      fi
      TARGET_DIR="$2"
      shift 2
      ;;
    --tools)
      if [[ $# -lt 2 ]]; then
        show_usage_and_exit "Missing value for --tools"
      fi
      TOOLS_CSV="$2"
      shift 2
      ;;
    --yes)
      NONINTERACTIVE=true
      shift
      ;;
    --help|-h)
      show_help_and_exit
      ;;
    *)
      show_usage_and_exit "Unknown option: $1"
      ;;
  esac
done

# Resolve target directory (client repo root)
if [[ -z "$TARGET_DIR" ]]; then
  if $NONINTERACTIVE; then
    TARGET_DIR="."
  else
    echo "Enter client repo root directory (default: .):"
    if [[ -e /dev/tty ]]; then
      read -r TARGET_DIR < /dev/tty
    else
      TARGET_DIR="."
      echo "(using current directory)"
    fi
    TARGET_DIR="${TARGET_DIR:-.}"
  fi
fi
if [[ ! -d "$TARGET_DIR" ]]; then
  show_usage_and_exit "Directory does not exist: $TARGET_DIR"
fi
if [[ "$TARGET_DIR" != /* ]]; then
  TARGET_DIR="$(cd "$TARGET_DIR" && pwd)"
fi
FRAMEWORK_DIR="$TARGET_DIR/$FRAMEWORK_DIRNAME"

preflight_checks

detect_engine_dir() {
  local base="$1"
  if [[ -x "$base/_localsetup/tools/deploy" ]]; then
    echo "$base/_localsetup"
    return 0
  fi
  if [[ -x "$base/tools/deploy" ]]; then
    echo "$base"
    return 0
  fi
  if [[ -x "$base/framework/tools/deploy" ]]; then
    echo "$base/framework"
    return 0
  fi
  return 1
}

sync_engine_tree() {
  local src="$1"
  local dst="$2"
  mkdir -p "$dst"

  # Keep user-local files, but replace framework-managed tree.
  rm -rf "$dst/config" "$dst/discovery" "$dst/docs" "$dst/lib" "$dst/skills" "$dst/templates" "$dst/tests" "$dst/tools"
  rm -f "$dst/README.md" "$dst/requirements.txt"

  cp -a "$src"/. "$dst"/

  # Clean legacy source-repo leftovers from older layouts.
  rm -rf "$dst/_localsetup" "$dst/framework" "$dst/.github" "$dst/.git"
}

# Resolve tools
if [[ -z "$TOOLS_CSV" ]]; then
  if $NONINTERACTIVE; then
    show_usage_and_exit "--tools is required when using --yes"
  fi
  echo "Select platform(s) to install (comma-separated):"
  echo "  1) cursor"
  echo "  2) claude-code"
  echo "  3) codex"
  echo "  4) openclaw"
  echo "Example: 1,2 for Cursor and Claude Code"
  if [[ -e /dev/tty ]]; then
    read -r TOOLS_CSV < /dev/tty
  else
    TOOLS_CSV="cursor"
    echo "(using cursor)"
  fi
fi
# Normalize: allow "cursor" or "1" etc.
TOOLS_CSV="$(echo "$TOOLS_CSV" | tr '[:upper:]' '[:lower:]' | sed 's/1/cursor/g; s/2/claude-code/g; s/3/codex/g; s/4/openclaw/g' | tr -d ' ')"
# Validate: each tool must be one of the supported four
VALID_TOOLS="cursor,claude-code,codex,openclaw"
for t in ${TOOLS_CSV//,/ }; do
  case "$t" in
    cursor|claude-code|codex|openclaw) ;;
    *)
      show_usage_and_exit "Invalid tool: '$t'. Valid values: cursor, claude-code, codex, openclaw"
      ;;
  esac
done
[[ -z "$TOOLS_CSV" ]] && show_usage_and_exit "At least one tool must be specified (e.g. --tools cursor)"

# Prepare framework source and enforce a single-level _localsetup install.
WORK_DIR=""
cleanup() {
  if [[ -n "$WORK_DIR" ]] && [[ -d "$WORK_DIR" ]]; then
    rm -rf "$WORK_DIR"
  fi
}
trap cleanup EXIT

SOURCE_BASE=""
if [[ -d "$FRAMEWORK_DIR/.git" ]]; then
  echo "Updating existing _localsetup source clone..."
  (cd "$FRAMEWORK_DIR" && git pull --rebase 2>/dev/null) || true
  SOURCE_BASE="$FRAMEWORK_DIR"
elif detect_engine_dir "$FRAMEWORK_DIR" >/dev/null 2>&1; then
  SOURCE_BASE="$FRAMEWORK_DIR"
else
  echo "Fetching Localsetup v2 source..."
  mkdir -p "$TARGET_DIR" || { echo "Error: Cannot create directory $TARGET_DIR" >&2; exit 1; }
  WORK_DIR="$(mktemp -d)"
  SOURCE_BASE="$WORK_DIR/localsetup-source"
  if ! git clone "$REPO_URL" "$SOURCE_BASE" 2>/dev/null; then
    echo "Error: Clone failed. Check network and repo URL (set LOCALSETUP_2_REPO to override)." >&2
    exit 1
  fi
fi

ENGINE_SRC="$(detect_engine_dir "$SOURCE_BASE" || true)"
if [[ -z "$ENGINE_SRC" ]]; then
  echo "Error: Could not locate framework engine in source." >&2
  echo "Checked for: tools/deploy, _localsetup/tools/deploy, framework/tools/deploy" >&2
  exit 1
fi

if [[ "$ENGINE_SRC" != "$FRAMEWORK_DIR" ]]; then
  echo "Preparing single-level framework at $FRAMEWORK_DIR..."
  sync_engine_tree "$ENGINE_SRC" "$FRAMEWORK_DIR"
fi

# Run deploy step from flattened install path.
DEPLOY_SCRIPT="$FRAMEWORK_DIR/tools/deploy"
if [[ -x "$DEPLOY_SCRIPT" ]]; then
  "$DEPLOY_SCRIPT" --tools "$TOOLS_CSV" --root "$TARGET_DIR" || { echo "Error: Deploy failed." >&2; exit 1; }
else
  echo "Error: Deploy script not found at $DEPLOY_SCRIPT" >&2
  exit 1
fi

echo "Done. Framework at $FRAMEWORK_DIR; platform files written to $TARGET_DIR."
